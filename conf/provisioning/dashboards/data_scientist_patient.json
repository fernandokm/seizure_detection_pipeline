{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": "-- Grafana --",
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "description": "Patient view",
  "editable": true,
  "gnetId": null,
  "graphTooltip": 0,
  "iteration": 1654101101109,
  "links": [
    {
      "icon": "dashboard",
      "tags": [],
      "title": "Accueil",
      "tooltip": "",
      "type": "link",
      "url": "/"
    }
  ],
  "panels": [
    {
      "aliasColors": {},
      "bars": false,
      "dashLength": 10,
      "dashes": false,
      "datasource": "aura-influxDB",
      "fieldConfig": {
        "defaults": {
          "custom": {}
        },
        "overrides": []
      },
      "fill": 1,
      "fillGradient": 0,
      "gridPos": {
        "h": 7,
        "w": 16,
        "x": 0,
        "y": 0
      },
      "hiddenSeries": false,
      "id": 2,
      "legend": {
        "avg": false,
        "current": false,
        "max": false,
        "min": false,
        "show": true,
        "total": false,
        "values": false
      },
      "lines": true,
      "linewidth": 1,
      "nullPointMode": "null",
      "options": {
        "alertThreshold": true
      },
      "percentage": false,
      "pluginVersion": "7.3.4",
      "pointradius": 2,
      "points": false,
      "renderer": "flot",
      "seriesOverrides": [],
      "spaceLength": 10,
      "stack": false,
      "steppedLine": false,
      "targets": [
        {
          "alias": "$feature_1",
          "groupBy": [
            {
              "params": [
                "1s"
              ],
              "type": "time"
            },
            {
              "params": [
                "patient"
              ],
              "type": "tag"
            },
            {
              "params": [
                "linear"
              ],
              "type": "fill"
            }
          ],
          "measurement": "features",
          "orderByTime": "ASC",
          "policy": "autogen",
          "query": "SELECT mean(/^$feature_1$/) FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter GROUP BY time(1s), \"patient\" fill(linear)",
          "queryType": "randomWalk",
          "rawQuery": true,
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "/^$feature_1$/"
                ],
                "type": "field"
              },
              {
                "params": [],
                "type": "mean"
              }
            ]
          ],
          "tags": [
            {
              "key": "patient",
              "operator": "=~",
              "value": "/^$patient$/"
            }
          ]
        }
      ],
      "thresholds": [],
      "timeFrom": null,
      "timeRegions": [],
      "timeShift": null,
      "title": "$feature_1",
      "tooltip": {
        "shared": true,
        "sort": 0,
        "value_type": "individual"
      },
      "type": "graph",
      "xaxis": {
        "buckets": null,
        "mode": "time",
        "name": null,
        "show": true,
        "values": []
      },
      "yaxes": [
        {
          "format": "short",
          "label": null,
          "logBase": 1,
          "max": null,
          "min": null,
          "show": true
        },
        {
          "format": "short",
          "label": null,
          "logBase": 1,
          "max": null,
          "min": null,
          "show": true
        }
      ],
      "yaxis": {
        "align": false,
        "alignLevel": null
      }
    },
    {
      "aliasColors": {},
      "cacheTimeout": null,
      "css_data": "",
      "datasource": null,
      "doInit": {},
      "fieldConfig": {
        "defaults": {
          "custom": {}
        },
        "overrides": []
      },
      "format": "short",
      "gridPos": {
        "h": 7,
        "w": 8,
        "x": 16,
        "y": 0
      },
      "handleMetric": {},
      "html_data": "Accuracy : 0.91\n<br>\nRecall : 0.72\n<br>\nPrecision : 0.73\n<br>\nF1 score : 0.62\n<br>\nSpecificity : 0.4",
      "id": 4,
      "interval": null,
      "js_code": "",
      "js_init_code": "",
      "links": [],
      "maxDataPoints": 3,
      "nullPointMode": "connected",
      "pluginVersion": "7.3.4",
      "targets": [
        {
          "queryType": "randomWalk",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Statistics",
      "type": "aidanmountford-html-panel"
    },
    {
      "datasource": "aura-influxDB",
      "fieldConfig": {
        "defaults": {
          "custom": {}
        },
        "overrides": []
      },
      "gridPos": {
        "h": 9,
        "w": 15,
        "x": 0,
        "y": 7
      },
      "id": 6,
      "options": {
        "config": {
          "displayModeBar": false
        },
        "data": null,
        "layout": {
          "font": {
            "color": "darkgrey"
          },
          "margin": {
            "b": 20,
            "l": 120,
            "t": 30
          },
          "paper_bgcolor": "rgba(0,0,0,0)",
          "plot_bgcolor": "rgba(0,0,0,0)"
        },
        "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
        "script": "// This file is NOT used in Grafana, it is simply a copy paste of the Javascript script used in the waterfall shap plot panel\n\n// The queries used to make it work are the following : \n\n// QUERY A (Table format, query on Influx DB)\n// SELECT * FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter\n\n\n\n// Max number of feature to plot\nlet max_feature_number = 10;\n\n// Base number for the waterfall plot\nlet mean_important_number = 0.1;\n\n// argsort function found online :\n// let argsort = a => a.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]).map(i => i[1])\n// my modification to sort by absolute value in a descending order\nlet argsort_abs_reverse = a => a.map((v, i) => [v, i]).sort((a, b) => Math.abs(b[0]) - Math.abs(a[0])).map(i => i[1]);\n\n// function to convert a timestamp of the form \"2006-10-09 09:06:22.000000\" to \"09:06:22\"\nfunction full_timestamp_to_hour(unix_time){\n    let date = new Date(unix_time)\n    // padStarts adds enough 0 at the beginning make sure the string length is 2 (ex : 7 --> 07)\n    return String(date.getHours()).padStart(2,0) + ':' + String(date.getMinutes()).padStart(2,0) + ':' + String(date.getSeconds()).padStart(2, 0)\n};\n\n\nfunction find_timestamps_of_crisis(timestamp, labels){\n    let begin_of_crisis = []\n    let end_of_crisis = []\n    let in_crisis = (labels[0] == 1)\n    if (in_crisis) {\n        begin_of_crisis.push(timestamp[0])\n    }\n    for (let i=0; i<labels.length; i++){\n        if (labels[i] == 1 & !in_crisis){\n            in_crisis = true\n            begin_of_crisis.push(timestamp[i])\n        }\n        if (labels[i] == 0 & in_crisis){\n            in_crisis = false\n            end_of_crisis.push(timestamp[i])\n        }\n        \n    };\n    return [begin_of_crisis, end_of_crisis];\n}\n\n\nconsole.log(data);\n// If there is no data (not the good time window for our patient for example)\nif (data.series.length == 0 ) {\n    return {};\n}\n\nlet all_fields = data.series[0].fields;\nlet only_shap_value_fields = [];\nlet timestamp = [];\nlet labels = [];\nlet predicted_labels = [];\n\n\n// loop on all the fields to retrieve only the shap_values fields and the timestamp one\nfor (let j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name == \"Time\") {\n        timestamp = all_fields[j].values.buffer;\n    };\n    if (all_fields[j].name == \"label\") {\n        labels = all_fields[j].values.buffer;\n    };\n    if (all_fields[j].name == \"predicted_label\") {\n        predicted_labels = all_fields[j].values.buffer;\n    };\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        only_shap_value_fields.push(all_fields[j])\n    };\n};\n\n\n// loop on the timestamp to retrieve for each instant the name of the features and the shap_values\nlet data_y = {};\nlet data_x = {};\nfor (let i = 0; i < timestamp.length; i++) {\n    if (!(timestamp[i] in data_y)) {\n        data_y[timestamp[i]] = []\n        data_x[timestamp[i]] = []\n    }\n    for (let j = 0; j < only_shap_value_fields.length; j++) {\n        data_x[timestamp[i]].push(only_shap_value_fields[j].values.buffer[i])\n        data_y[timestamp[i]].push(only_shap_value_fields[j].name.substring(12))\n    };\n};\n\n// data_x_i is a list of shap values for a given timestamp\n// data_y_i is a list of feature names for a given timestamp\nfunction construct_shap_waterfall(data_x_i, data_y_i) {\n    let inds = argsort_abs_reverse(data_x_i); // Sorting in descending order + for absolute values\n    let ind = -1;\n    let new_data_x_i = [];\n    let new_data_y_i = [];\n    for (let i = 0; i < Math.min(inds.length, max_feature_number); i++) {\n        ind = inds[i]\n        // Plotly plots the first element at the bottom, and we want the biggest elements to be at the top\n        new_data_x_i.unshift(data_x_i[ind]);  // unshift allows to push at the beginning of the array\n        new_data_y_i.unshift(data_y_i[ind]);\n    };\n    let last_value = 0;\n    for (let i = Math.min(inds.length, max_feature_number); i < Math.max(inds.length, max_feature_number); i++) {\n        last_value += data_x_i[inds[i]];\n    };\n\n    new_data_x_i.unshift(last_value);\n    new_data_y_i.unshift(\"Other\");\n    // We want this regroupment to be at the bottom\n    return [ new_data_x_i, new_data_y_i ];\n};\n\nfunction find_data_x_i_extrema(data_x_i){\n    let data_x_i_min = 1000;\n    let data_x_i_max = -1000;\n    let current_value = 0;\n    for (let i = 0; i < data_x_i.length ; i++) {\n        current_value += data_x_i[i]\n        if (current_value < data_x_i_min) {\n            data_x_i_min = current_value;\n        };\n        if (current_value > data_x_i_max) {\n            data_x_i_max = current_value;\n        };\n    };\n    return [data_x_i_min, data_x_i_max]\n};\n\nlet frames = [];\nlet x_range_min = 1000;\nlet x_range_max = -1000;\n// for (let i = 0; i < 100; i++) {\nfor (let i = 0; i < timestamp.length; i++) {\n    let [ new_data_x_i, new_data_y_i ] = construct_shap_waterfall(data_x[timestamp[i]], data_y[timestamp[i]]);\n    let [data_x_i_min, data_x_i_max] = find_data_x_i_extrema(new_data_x_i)\n    if (data_x_i_max > x_range_max) {\n        x_range_max = data_x_i_max\n    };\n    if (data_x_i_min < x_range_min) {\n        x_range_min = data_x_i_min\n    }; \n    frames.push({\n        name: timestamp[i],\n        data: [{\n            x: new_data_x_i,\n            y: new_data_y_i,\n        }],\n    });\n};\n\nlet sliderSteps = [];\n// for (let i = 0; i < 100; i++) {\nfor (let i = 0; i < timestamp.length; i++) {\n    sliderSteps.push({\n        method: 'animate',\n        label: full_timestamp_to_hour(timestamp[i]),\n        args: [[timestamp[i]], {\n            mode: 'immediate',\n            transition: { duration: 0 },\n            frame: { duration: 0, redraw: true },\n        }]\n    });\n}\n\nlet [begin_of_real_crisis, end_of_real_crisis] = find_timestamps_of_crisis(timestamp, labels);\nlet [begin_of_predicted_crisis, end_of_predicted_crisis] = find_timestamps_of_crisis(timestamp, predicted_labels);\n\nlet real_crisis_buttons_beginning = [];\nlet predicted_crisis_buttons_beginning = [];\n\n\nfor (let i = 0; i < begin_of_real_crisis.length; i++)  {\n    real_crisis_buttons_beginning.push({\n        label: full_timestamp_to_hour(begin_of_real_crisis[i]),\n        method: 'animate',\n        args: [[begin_of_real_crisis[i]], {\n            mode: 'immediate',\n            transition: { duration: 0 },\n            frame: { duration: 0, redraw: true }\n        }]\n    });\n};\nfor (let i = 0; i < begin_of_predicted_crisis.length; i++) {\n    predicted_crisis_buttons_beginning.push({\n        label: full_timestamp_to_hour(begin_of_predicted_crisis[i]),\n        method: 'animate',\n        args: [[begin_of_predicted_crisis[i]], {\n            mode: 'immediate',\n            transition: { duration: 0 },\n            frame: { duration: 0, redraw: true }\n        }]\n    });\n};\n\nlet layout = {\n    sliders: [{\n        steps: sliderSteps\n    }],\n    updatemenus: [{\n        type: 'buttons', \n        showactive: false,\n        x : -0.5,\n        xanchor: 'center',\n        yanchor: 'top',\n        buttons: real_crisis_buttons_beginning\n      },\n      {\n        type: 'buttons',\n        showactive: false,\n        x : -0.3,\n        xanchor: 'center',\n        yanchor: 'top',\n        buttons: predicted_crisis_buttons_beginning\n      }\n    ],\n    annotations : [{\n        xref: 'paper',\n        yref: 'paper',\n        x: -0.5,\n        xanchor: 'center',\n        y: 1,\n        yanchor: 'bottom',\n        text: 'Real crises',\n        showarrow: false\n    }, {\n        xref: 'paper',\n        yref: 'paper',\n        x: -0.3,\n        xanchor: 'center',\n        y: 1,\n        yanchor: 'bottom',\n        text: 'Predicted crises',\n        showarrow: false\n    }],\n    // The range is the min and max for all the graphs on the slider +/- 10% of the range\n    xaxis: { range: [x_range_min - 0.1 * (x_range_max - x_range_min) + mean_important_number, x_range_max + 0.1 * (x_range_max - x_range_min) + mean_important_number] }\n};\n\nlet [ new_data_x_i, new_data_y_i ] = construct_shap_waterfall(data_x[timestamp[0]], data_y[timestamp[0]])\nlet relative = []\nfor (let i = 0; i < new_data_x_i.length; i++) {\n    relative.push(\"relative\")\n}\n\nlet trace = {\n    x: new_data_x_i,\n    y: new_data_y_i,\n    // measure: relative,\n    type: \"waterfall\",\n    // type:\"bar\",\n    orientation: \"h\",\n    base: mean_important_number,\n}\n\n\nreturn {\n    data: [trace],\n    layout: layout,\n    frames: frames\n};"
      },
      "pluginVersion": "7.3.4",
      "targets": [
        {
          "groupBy": [
            {
              "params": [
                "$__interval"
              ],
              "type": "time"
            },
            {
              "params": [
                "null"
              ],
              "type": "fill"
            }
          ],
          "orderByTime": "ASC",
          "policy": "default",
          "query": "SELECT * FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter",
          "rawQuery": true,
          "refId": "A",
          "resultFormat": "table",
          "select": [
            [
              {
                "params": [
                  "value"
                ],
                "type": "field"
              },
              {
                "params": [],
                "type": "mean"
              }
            ]
          ],
          "tags": []
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Shap waterfall plot",
      "type": "ae3e-plotly-panel"
    },
    {
      "datasource": "aura-influxDB",
      "fieldConfig": {
        "defaults": {
          "custom": {}
        },
        "overrides": []
      },
      "gridPos": {
        "h": 9,
        "w": 9,
        "x": 15,
        "y": 7
      },
      "id": 8,
      "options": {
        "config": {
          "displayModeBar": false
        },
        "data": "",
        "layout": "",
        "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
        "script": "// This file is NOT used in Grafana, it is simply a copy paste of the Javascript script used in the correlation plot panel\n\n// The queries used to make it work are the following : \n\n// QUERY A : \n// SELECT /^$feature_1$/, /^$feature_2$/ FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter\n\nconsole.log(data)\n\nlet trace = {\n    x: data.series[0].fields[1].values.buffer,\n    y: data.series[0].fields[2].values.buffer,\n    marker: {\n        color: \"rgba(77, 189, 204, 1)\",\n        size: 3,\n    },\n    mode: \"markers\",\n    type: \"scatter\"\n};\n\nlet layout = {\n    margin: {\n        b: 30\n    },\n    xaxis: {\n        title: {\n            text: data.series[0].fields[1].name,\n        },\n        type : \"linear\",\n    },\n    yaxis: {\n        title: {\n            text: data.series[0].fields[2].name,\n        }\n    },\n  }\n\n  \nreturn {data:[trace], layout:layout};"
      },
      "pluginVersion": "7.3.4",
      "targets": [
        {
          "groupBy": [],
          "measurement": "features",
          "orderByTime": "ASC",
          "policy": "autogen",
          "query": "SELECT /^$feature_1$/, /^$feature_2$/ FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter",
          "rawQuery": true,
          "refId": "A",
          "resultFormat": "table",
          "select": [
            [
              {
                "params": [
                  "/^$feature_2$/"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": [
            {
              "key": "patient",
              "operator": "=~",
              "value": "/^$patient$/"
            }
          ]
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Correlation between $feature_1 and $feature_2",
      "type": "ae3e-plotly-panel"
    },
    {
      "datasource": "aura-influxDB",
      "fieldConfig": {
        "defaults": {
          "custom": {}
        },
        "overrides": []
      },
      "gridPos": {
        "h": 9,
        "w": 24,
        "x": 0,
        "y": 16
      },
      "id": 10,
      "options": {
        "config": {
          "displayModeBar": false
        },
        "data": null,
        "layout": {
          "font": {
            "color": "darkgrey"
          },
          "margin": {
            "b": 20,
            "l": 20,
            "t": 10
          },
          "paper_bgcolor": "rgba(0,0,0,0)",
          "plot_bgcolor": "rgba(0,0,0,0)"
        },
        "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
        "script": "// This file is NOT used in Grafana, it is simply a copy paste of the Javascript script used in the summary shap plot panel\n\n// The queries used to make it work are the following : \n\n// QUERY A : \n// SELECT * FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter\n\n\n\n// Max number of feature to plot\nvar max_feature_number = 6\n\n// argsort function found online and modified so that it sorts in descending order\nlet argsort = a => a.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]).map(i => i[1])\n\n\n// Standard Normal variate using Box-Muller transform (also found online obviously)\nfunction randn_bm() {\n    var u = 0, v = 0;\n    while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while (v === 0) v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n}\n\n// Shuffle function based on the Fisher-Yates (aka Knuth) Shuffle (once again found online)\nfunction shuffle(array) {\n    let currentIndex = array.length, randomIndex;\n\n    // While there remain elements to shuffle.\n    while (currentIndex != 0) {\n\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n\n    return array;\n}\n\n// Function to get the shap colors\nfunction get_shap_colors(z) {\n    var colors = [];\n    var sorted_z = [...z].sort((a, b) => a - b)\n    first_decile = Math.floor(sorted_z.length * 0.05) - 1;\n    last_decile = Math.floor(sorted_z.length * 0.95) - 1;;\n\n    var z_max = sorted_z[last_decile];\n    var z_min = sorted_z[first_decile];\n\n    var available_colors = [\"#007bff\", \"#0069f8\", \"#5153e9\", \"#7e35d6\", \"#9d00be\", \"#bc00ab\", \"#db009a\", \"#f30086\", \"#ff0071\", \"#ff0059\"];\n\n    for (var i = 0; i < z.length; i++) {\n        if (z_min > z[i]) {\n            colors.push(available_colors[0]);\n        };\n        for (var j = 0; j < available_colors.length; j++) {\n            if (j * (z_max - z_min) / available_colors.length + z_min <= z[i] && (j + 1) * (z_max - z_min) / available_colors.length + z_min > z[i]) {\n                colors.push(available_colors[j]);\n                break;\n            };\n        };\n        if (z_max <= z[i]) {\n            colors.push(available_colors[available_colors.length - 1]);\n        };\n    };\n\n\n    return { colors, z_min, z_max };\n};\n\n\nfunction get_trace_for_one_feature(not_shuffled_shaps, not_shuffled_values, pos, colorbar) {\n    // Shuffle the shaps and values\n    var inds = [];\n    for (var i = 0; i < not_shuffled_shaps.length; i++) {\n        inds.push(i);\n    }\n    inds = shuffle(inds);\n    (shaps = []).length = inds.length; shaps.fill(0);\n    (values = []).length = inds.length; values.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        shaps[i] = not_shuffled_shaps[inds[i]];\n        values[i] = not_shuffled_values[inds[i]];\n    }\n\n\n    var n_bins = 100;\n\n    var quant = [];\n    var quant_plus_random = [];\n    var max_shap = Math.max(...shaps);\n    var min_shap = Math.min(...shaps);\n\n    for (var i = 0; i < shaps.length; i++) {\n        quant.push(Math.round(n_bins * (shaps[i] - min_shap) / (max_shap - min_shap)));\n        quant_plus_random.push(quant[i] + randn_bm() * 10 ** (-6));\n    }\n\n    var inds = argsort(quant_plus_random);\n    var layer = 0;\n    var last_bin = -1;\n    var ind = -1;\n    (ys = []).length = shaps.length; ys.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        ind = inds[i];\n        if (!(quant[ind] == last_bin)) {\n            layer = 0;\n        };\n        ys[ind] = Math.ceil(layer / 2) * ((layer % 2) * 2 - 1);\n        layer += 1;\n        last_bin = quant[ind];\n    };\n\n    let { colors, z_min, z_max } = get_shap_colors(values);\n\n    // reverse the x axis and resize the y axis\n    var negative_shaps = [];\n    var resized_ys = [];\n    var row_height = 0.4;\n    for (i = 0; i < shaps.length; i++) {\n        negative_shaps.push(-1 * shaps[i]);\n        resized_ys.push(ys[i] * (0.9 * row_height / (Math.max(...ys) + 1)) + pos);\n    };\n\n    var trace = {\n        x: negative_shaps,\n        y: resized_ys,\n        type: \"scatter\",\n        mode: \"markers\",\n    };\n    var marker = {}\n\n    if (colorbar) {\n        marker = {\n            color: colors,\n            colorscale: [[0, \"#007bff\"], [0.1, \"#0069f8\"], [0.2, \"#5153e9\"], [0.3, \"#7e35d6\"], [0.4, \"#9d00be\"], [0.5, \"#bc00ab\"], [0.6, \"#db009a\"], [0.7, \"#f30086\"], [0.8, \"#ff0071\"], [1, \"#ff0059\"]],\n            showscale: true,\n            colorbar: {\n                tickmode: 'array',\n                ticktext: [\"Low\", \"High\"],\n                tickvals: [0, 1],\n                // showticklabels: false,\n                thicknessmode: \"pixel\",\n                thickness: 10,\n                title: {\n                    text: 'Feature value',\n                    side: 'right'\n                },\n            },\n            cmin: 0,\n            cmax: 1\n        };\n    } else {\n        marker = {\n            color: colors,\n        }\n    }\n    trace[\"marker\"] = marker\n\n    return trace\n\n};\n\nfunction calculate_variance(shaps) {\n    var result = 0\n    for (i = 0; i < shaps.length; i++) {\n        result += Math.abs(shaps[i])\n    };\n    return result\n};\n\n// Sometimes the beginning of the shap fields can have null values. (because some features are calculated \n// on the past minute or so, they thus don't have a value for the first 60 seconds)\n// Lukily the index at which the last null is is the same for all shap values fields, so we use any shap\n// value field to find this index. Then we will slide all shap_values and feature_values fields with this index\nfunction find_first_not_null_index(shap_values){\n    for (let i = 0; i < shap_values.length; i++){\n        if (shap_values[i] != null) {\n            return i\n        }\n    };\n};\n\n\nconsole.log(data);\nif (data.series.length == 0) {\n    return {}\n}\nvar all_fields = data.series[0].fields;\nvar feature_name = \"\";\nvar list_feature_names = [];\nvar data_dict = {};\n\n\n\nlet first_not_null_index = -1 \n\n// We retrieve the names of all the features which have their shap_values calculated\nfor (var j = 0; j < all_fields.length; j++) {\n    \n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        if (first_not_null_index == -1) {\n            first_not_null_index = find_first_not_null_index(all_fields[j].values.buffer)\n        }\n        feature_name = all_fields[j].name.substring(12); // substring(12) to remove 'shap_values_'\n        data_dict[feature_name] = {};\n        list_feature_names.push(feature_name);\n    };\n};\n\n\n\n\n\n// Store in data_dict the shap values, the feature values and the variance of the shap values (we'll have to sort by this variance afterwards)\nfor (var j = 0; j < all_fields.length; j++) {\n    // if the field contain the shap values\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        feature_name = all_fields[j].name.substring(12)\n        data_dict[feature_name][\"shaps\"] = all_fields[j].values.buffer.slice(first_not_null_index)\n        data_dict[feature_name][\"variance\"] = calculate_variance(all_fields[j].values.buffer.slice(first_not_null_index))\n    // if the field contain the feature values\n    } else if (data_dict.hasOwnProperty(all_fields[j].name)) {\n        feature_name = all_fields[j].name\n        data_dict[feature_name][\"values\"] = all_fields[j].values.buffer.slice(first_not_null_index)\n    }\n}\n\n// Sorting the features by decreasing order of variance\nvar sorted_feature_names = list_feature_names.sort(function (first, second) {\n    return data_dict[second].variance - data_dict[first].variance;\n});\n\nvar final_number_of_plots = Math.min(max_feature_number, sorted_feature_names.length)\n\n// Getting x position of features name annotation\nvar min_x_shaps_value = 0\nvar max_x_shaps_value = 0\nfor (i = 0; i < final_number_of_plots; i++) {\n    if (max_x_shaps_value < Math.max(...data_dict[sorted_feature_names[i]][\"shaps\"])) {\n        max_x_shaps_value = Math.max(...data_dict[sorted_feature_names[i]][\"shaps\"])\n    }\n    if (min_x_shaps_value > Math.min(...data_dict[sorted_feature_names[i]][\"shaps\"])) {\n        min_x_shaps_value = Math.min(...data_dict[sorted_feature_names[i]][\"shaps\"])\n    }\n}\n\n// Shap values are actually inverted when plotting so we take the \n// negative of the max minus a small percentage of the range\nvar x_annotation_pos = -1 * max_x_shaps_value - 0.1 * (max_x_shaps_value - min_x_shaps_value)\n\nvar traces = []\nvar annotations = []\nfor (i = 0; i < final_number_of_plots; i++) {\n    // we want to have the plot with biggest variance at the top of our graph\n    j = final_number_of_plots - i\n    traces.push(get_trace_for_one_feature(data_dict[sorted_feature_names[i]][\"shaps\"], data_dict[sorted_feature_names[i]][\"values\"], j + 1, (i == 0)))\n    annotations.push(\n        {\n            x: x_annotation_pos,\n            xanchor: 'right',\n            y: j + 1,\n            yanchor: 'center',\n            text: sorted_feature_names[i],\n            showarrow: false\n        }\n    )\n}\n\n\n\n\nvar layout = {\n    font: {\n        color: \"darkgrey\"\n    },\n    paper_bgcolor: \"rgba(0,0,0,0)\",\n    plot_bgcolor: \"rgba(0,0,0,0)\",\n    xaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: true,\n        type: \"linear\"\n    },\n    yaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: false,\n        visible: false,\n        type: \"linear\"\n    },\n    showlegend: false,\n    annotations: annotations\n}\n\nreturn { data: traces, layout: layout };"
      },
      "pluginVersion": "7.3.4",
      "targets": [
        {
          "groupBy": [],
          "measurement": "features",
          "orderByTime": "ASC",
          "policy": "autogen",
          "query": "SELECT * FROM \"autogen\".\"features\" WHERE (\"patient\" =~ /^$patient$/) AND $timeFilter",
          "rawQuery": true,
          "refId": "A",
          "resultFormat": "table",
          "select": [
            [
              {
                "params": [
                  "*"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": [
            {
              "key": "patient",
              "operator": "=~",
              "value": "/^$patient$/"
            },
            {
              "condition": "AND",
              "key": "patient",
              "operator": "=",
              "value": "select tag value"
            }
          ]
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Shap summary plot",
      "type": "ae3e-plotly-panel"
    }
  ],
  "refresh": false,
  "schemaVersion": 26,
  "style": "dark",
  "tags": [],
  "templating": {
    "list": [
      {
        "allValue": null,
        "current": {
          "selected": false,
          "text": "00004671_s007_t000",
          "value": "00004671_s007_t000"
        },
        "datasource": "aura-influxDB",
        "definition": "",
        "error": null,
        "hide": 0,
        "includeAll": false,
        "label": "Patient",
        "multi": false,
        "name": "patient",
        "options": [],
        "query": "SHOW TAG VALUES WITH KEY=\"patient\"",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "tagValuesQuery": "",
        "tags": [],
        "tagsQuery": "",
        "type": "query",
        "useTags": false
      },
      {
        "allValue": null,
        "current": {
          "selected": false,
          "text": "Modified_csi",
          "value": "Modified_csi"
        },
        "datasource": "aura-influxDB",
        "definition": "",
        "error": null,
        "hide": 0,
        "includeAll": false,
        "label": "Main feature",
        "multi": false,
        "name": "feature_1",
        "options": [
          {
            "selected": true,
            "text": "Modified_csi",
            "value": "Modified_csi"
          },
          {
            "selected": false,
            "text": "csi",
            "value": "csi"
          },
          {
            "selected": false,
            "text": "cvi",
            "value": "cvi"
          },
          {
            "selected": false,
            "text": "cvnni",
            "value": "cvnni"
          },
          {
            "selected": false,
            "text": "cvsd",
            "value": "cvsd"
          },
          {
            "selected": false,
            "text": "filename",
            "value": "filename"
          },
          {
            "selected": false,
            "text": "hf",
            "value": "hf"
          },
          {
            "selected": false,
            "text": "index",
            "value": "index"
          },
          {
            "selected": false,
            "text": "interval_index",
            "value": "interval_index"
          },
          {
            "selected": false,
            "text": "interval_start_time",
            "value": "interval_start_time"
          },
          {
            "selected": false,
            "text": "label",
            "value": "label"
          },
          {
            "selected": false,
            "text": "lf",
            "value": "lf"
          },
          {
            "selected": false,
            "text": "lf_hf_ratio",
            "value": "lf_hf_ratio"
          },
          {
            "selected": false,
            "text": "max_hr",
            "value": "max_hr"
          },
          {
            "selected": false,
            "text": "mean_hr",
            "value": "mean_hr"
          },
          {
            "selected": false,
            "text": "mean_nni",
            "value": "mean_nni"
          },
          {
            "selected": false,
            "text": "median_nni",
            "value": "median_nni"
          },
          {
            "selected": false,
            "text": "min_hr",
            "value": "min_hr"
          },
          {
            "selected": false,
            "text": "model",
            "value": "model"
          },
          {
            "selected": false,
            "text": "nni_20",
            "value": "nni_20"
          },
          {
            "selected": false,
            "text": "nni_50",
            "value": "nni_50"
          },
          {
            "selected": false,
            "text": "pnni_20",
            "value": "pnni_20"
          },
          {
            "selected": false,
            "text": "pnni_50",
            "value": "pnni_50"
          },
          {
            "selected": false,
            "text": "predicted_label",
            "value": "predicted_label"
          },
          {
            "selected": false,
            "text": "range_nni",
            "value": "range_nni"
          },
          {
            "selected": false,
            "text": "ratio_sd2_sd1",
            "value": "ratio_sd2_sd1"
          },
          {
            "selected": false,
            "text": "rmssd",
            "value": "rmssd"
          },
          {
            "selected": false,
            "text": "sampen",
            "value": "sampen"
          },
          {
            "selected": false,
            "text": "sd1",
            "value": "sd1"
          },
          {
            "selected": false,
            "text": "sd2",
            "value": "sd2"
          },
          {
            "selected": false,
            "text": "sdnn",
            "value": "sdnn"
          },
          {
            "selected": false,
            "text": "sdsd",
            "value": "sdsd"
          },
          {
            "selected": false,
            "text": "std_hr",
            "value": "std_hr"
          },
          {
            "selected": false,
            "text": "vlf",
            "value": "vlf"
          }
        ],
        "query": "SHOW FIELD KEYS FROM features",
        "refresh": 0,
        "regex": "^((?!(shap_values|lime_values)).*)",
        "skipUrlSync": false,
        "sort": 0,
        "tagValuesQuery": "",
        "tags": [],
        "tagsQuery": "",
        "type": "query",
        "useTags": false
      },
      {
        "allValue": null,
        "current": {
          "selected": false,
          "text": "cvsd",
          "value": "cvsd"
        },
        "datasource": "aura-influxDB",
        "definition": "",
        "error": null,
        "hide": 0,
        "includeAll": false,
        "label": "Secondary feature",
        "multi": false,
        "name": "feature_2",
        "options": [
          {
            "selected": false,
            "text": "Modified_csi",
            "value": "Modified_csi"
          },
          {
            "selected": false,
            "text": "csi",
            "value": "csi"
          },
          {
            "selected": false,
            "text": "cvi",
            "value": "cvi"
          },
          {
            "selected": false,
            "text": "cvnni",
            "value": "cvnni"
          },
          {
            "selected": true,
            "text": "cvsd",
            "value": "cvsd"
          },
          {
            "selected": false,
            "text": "filename",
            "value": "filename"
          },
          {
            "selected": false,
            "text": "hf",
            "value": "hf"
          },
          {
            "selected": false,
            "text": "index",
            "value": "index"
          },
          {
            "selected": false,
            "text": "interval_index",
            "value": "interval_index"
          },
          {
            "selected": false,
            "text": "interval_start_time",
            "value": "interval_start_time"
          },
          {
            "selected": false,
            "text": "label",
            "value": "label"
          },
          {
            "selected": false,
            "text": "lf",
            "value": "lf"
          },
          {
            "selected": false,
            "text": "lf_hf_ratio",
            "value": "lf_hf_ratio"
          },
          {
            "selected": false,
            "text": "max_hr",
            "value": "max_hr"
          },
          {
            "selected": false,
            "text": "mean_hr",
            "value": "mean_hr"
          },
          {
            "selected": false,
            "text": "mean_nni",
            "value": "mean_nni"
          },
          {
            "selected": false,
            "text": "median_nni",
            "value": "median_nni"
          },
          {
            "selected": false,
            "text": "min_hr",
            "value": "min_hr"
          },
          {
            "selected": false,
            "text": "model",
            "value": "model"
          },
          {
            "selected": false,
            "text": "nni_20",
            "value": "nni_20"
          },
          {
            "selected": false,
            "text": "nni_50",
            "value": "nni_50"
          },
          {
            "selected": false,
            "text": "pnni_20",
            "value": "pnni_20"
          },
          {
            "selected": false,
            "text": "pnni_50",
            "value": "pnni_50"
          },
          {
            "selected": false,
            "text": "predicted_label",
            "value": "predicted_label"
          },
          {
            "selected": false,
            "text": "range_nni",
            "value": "range_nni"
          },
          {
            "selected": false,
            "text": "ratio_sd2_sd1",
            "value": "ratio_sd2_sd1"
          },
          {
            "selected": false,
            "text": "rmssd",
            "value": "rmssd"
          },
          {
            "selected": false,
            "text": "sampen",
            "value": "sampen"
          },
          {
            "selected": false,
            "text": "sd1",
            "value": "sd1"
          },
          {
            "selected": false,
            "text": "sd2",
            "value": "sd2"
          },
          {
            "selected": false,
            "text": "sdnn",
            "value": "sdnn"
          },
          {
            "selected": false,
            "text": "sdsd",
            "value": "sdsd"
          },
          {
            "selected": false,
            "text": "std_hr",
            "value": "std_hr"
          },
          {
            "selected": false,
            "text": "vlf",
            "value": "vlf"
          }
        ],
        "query": "SHOW FIELD KEYS FROM features",
        "refresh": 0,
        "regex": "^((?!(shap_values|lime_values)).*)",
        "skipUrlSync": false,
        "sort": 0,
        "tagValuesQuery": "",
        "tags": [],
        "tagsQuery": "",
        "type": "query",
        "useTags": false
      }
    ]
  },
  "time": {
    "from": "2012-08-04T16:01:05.031Z",
    "to": "2012-08-04T16:13:40.082Z"
  },
  "timepicker": {},
  "timezone": "",
  "title": "Patient | Data scientist layout",
  "uid": "dstLyt",
  "version": 14
}