{
    "annotations": {
        "list": [
            {
                "builtIn": 1,
                "datasource": "-- Grafana --",
                "enable": true,
                "hide": true,
                "iconColor": "rgba(0, 211, 255, 1)",
                "name": "Annotations & Alerts",
                "type": "dashboard"
            }
        ]
    },
    "editable": true,
    "gnetId": null,
    "graphTooltip": 0,
    "id": 9,
    "links": [],
    "panels": [
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 12,
                "w": 15,
                "x": 0,
                "y": 0
            },
            "id": 11,
            "options": {
                "config": {
                    "displayModeBar": false
                },
                "data": [
                    {
                        "mode": "markers",
                        "type": "scatter"
                    }
                ],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)"
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "// argsort function found online :\nvar argsort = a => a.map((v, i) => [v, i]).sort().map(i => i[1])\n\n// Standard Normal variate using Box-Muller transform (also found online obviously)\nfunction randn_bm() {\n    var u = 0, v = 0;\n    while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while (v === 0) v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n}\n\n// Shuffle function based on the Fisher-Yates (aka Knuth) Shuffle (once again found online)\nfunction shuffle(array) {\n    let currentIndex = array.length, randomIndex;\n\n    // While there remain elements to shuffle.\n    while (currentIndex != 0) {\n\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n\n    return array;\n}\n\n// Function to get the shap colors\nfunction get_shap_colors(z) {\n    var colors = [];\n    var sorted_z = [...z].sort((a, b) => a - b)\n    first_decile = Math.floor(sorted_z.length * 0.05) - 1;\n    last_decile = Math.floor(sorted_z.length * 0.95) - 1;;\n\n    var z_max = sorted_z[last_decile];\n    var z_min = sorted_z[first_decile];\n\n    var available_colors = [\"#007bff\", \"#0069f8\", \"#5153e9\", \"#7e35d6\", \"#9d00be\", \"#bc00ab\", \"#db009a\", \"#f30086\", \"#ff0071\", \"#ff0059\"];\n\n    for (var i = 0; i < z.length; i++) {\n        if (z_min > z[i]) {\n            colors.push(available_colors[0]);\n        };\n        for (var j = 0; j < available_colors.length; j++) {\n            if (j * (z_max - z_min) / available_colors.length + z_min <= z[i] && (j + 1) * (z_max - z_min) / available_colors.length + z_min > z[i]) {\n                colors.push(available_colors[j]);\n                break;\n            };\n        };\n        if (z_max <= z[i]) {\n            colors.push(available_colors[available_colors.length - 1]);\n        };\n    };\n\n    return { colors, z_min, z_max };\n};\n\n\nfunction get_trace_for_one_feature(not_shuffled_shaps, not_shuffled_values, pos) {\n    // Shuffle the shaps and values\n    var inds = [];\n    for (var i = 0; i < not_shuffled_shaps.length; i++) {\n        inds.push(i);\n    }\n    inds = shuffle(inds);\n    (shaps = []).length = inds.length; shaps.fill(0);\n    (values = []).length = inds.length; values.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        shaps[i] = not_shuffled_shaps[inds[i]];\n        values[i] = not_shuffled_values[inds[i]];\n    }\n\n\n    var n_bins = 100;\n\n    var quant = [];\n    var quant_plus_random = [];\n    var max_shap = Math.max(...shaps);\n    var min_shap = Math.min(...shaps);\n\n    for (var i = 0; i < shaps.length; i++) {\n        quant.push(Math.round(n_bins * (shaps[i] - min_shap) / (max_shap - min_shap)));\n        quant_plus_random.push(quant[i] + randn_bm() * 10 ** (-6));\n    }\n\n    var inds = argsort(quant_plus_random);\n    var layer = 0;\n    var last_bin = -1;\n    var ind = -1;\n    (ys = []).length = shaps.length; ys.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        ind = inds[i];\n        if (!(quant[ind] == last_bin)) {\n            layer = 0;\n        };\n        ys[ind] = Math.ceil(layer / 2) * ((layer % 2) * 2 - 1);\n        layer += 1;\n        last_bin = quant[ind];\n    };\n\n    let { colors, z_min, z_max } = get_shap_colors(values);\n\n    // reverse the x axis and resize the y axis\n    var negative_shaps = [];\n    var resized_ys = [];\n    var row_height = 0.4;\n    for (i = 0; i < shaps.length; i++) {\n        negative_shaps.push(-1 * shaps[i]);\n        resized_ys.push(ys[i] * (0.9 * row_height / (Math.max(...ys) + 1)) + pos);\n    };\n\n    var trace = {\n        x: negative_shaps,\n        y: resized_ys,\n        type: \"scatter\",\n        mode: \"markers\",\n        marker: {\n            color: colors\n        }\n    };\n\n    return trace\n\n};\n\nfunction calculate_variance(shaps) {\n    var result = 0\n    for (i = 0; i < shaps.length; i++) {\n        result += Math.abs(shaps[i])\n    }\n    return result\n}\n\nconsole.log(data);\nvar all_fields = data.series[0].fields;\nvar feature_name = \"\";\nvar list_feature_names = [];\nvar data_dict = {};\nfor (var j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        feature_name = all_fields[j].name.substring(12);\n        data_dict[feature_name] = {};\n        list_feature_names.push(feature_name);\n    };\n};\n\nfor (var j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        feature_name = all_fields[j].name.substring(12)\n        data_dict[feature_name][\"shaps\"] = all_fields[j].values.buffer\n        data_dict[feature_name][\"variance\"] = calculate_variance(all_fields[j].values.buffer)\n    } else if (data_dict.hasOwnProperty(all_fields[j].name)) {\n        feature_name = all_fields[j].name\n        data_dict[feature_name][\"values\"] = all_fields[j].values.buffer\n    }\n}\n\n\n// Sorting the features by decreasing order of variance\nvar sorted_feature_names = list_feature_names.sort(function (first, second) {\n    return data_dict[second].variance - data_dict[first].variance;\n});\n\nvar max_feature_number = 10\n\n// Getting x position of features name annotation\nvar min_x_shaps_value = 0\nvar max_x_shaps_value = 0\nfor (i = 0; i < Math.min(max_feature_number, sorted_feature_names.length); i++) {\n    if (max_x_shaps_value < Math.max(...data_dict[sorted_feature_names[i]][\"shaps\"])) {\n\n        max_x_shaps_value = Math.max(...data_dict[sorted_feature_names[i]][\"shaps\"])\n    }\n    if (min_x_shaps_value > Math.min(...data_dict[sorted_feature_names[i]][\"shaps\"])) {\n        min_x_shaps_value = Math.min(...data_dict[sorted_feature_names[i]][\"shaps\"])\n    }\n}\n// Shap values are actually inverted when plotting so we take the \n// negative of the max minus a small percentage of the range\nvar x_annotation_pos = -1 * max_x_shaps_value - 0.1 * (max_x_shaps_value - min_x_shaps_value)\n\nvar traces = []\nvar annotations = []\nfor (i = 0; i < Math.min(max_feature_number, sorted_feature_names.length); i++) {\n    traces.push(get_trace_for_one_feature(data_dict[sorted_feature_names[i]][\"shaps\"], data_dict[sorted_feature_names[i]][\"values\"], i + 1))\n    annotations.push(\n        {\n            x: x_annotation_pos,\n            xanchor: 'right',\n            y: i + 1,\n            yanchor: 'center',\n            text: sorted_feature_names[i],\n            showarrow: false\n        }\n    )\n}\n\n\n\n\nvar layout = {\n    font: {\n        color: \"darkgrey\"\n    },\n    paper_bgcolor: \"rgba(0,0,0,0)\",\n    plot_bgcolor: \"rgba(0,0,0,0)\",\n    xaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: true,\n        type: \"linear\"\n    },\n    yaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: false,\n        visible: false,\n        type: \"linear\"\n    },\n    showlegend: false,\n    annotations: annotations\n}\n\nreturn { data: traces, layout: layout };"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  *\nFROM shap_data",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "value_double"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "test_data",
                    "timeColumn": "time_date_time",
                    "timeColumnType": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Shap summary plot",
            "type": "ae3e-plotly-panel"
        },
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 12,
                "w": 15,
                "x": 0,
                "y": 12
            },
            "id": 12,
            "options": {
                "config": {
                    "displayModeBar": false
                },
                "data": [
                    {
                        "mode": "markers",
                        "type": "scatter"
                    }
                ],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)"
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "// How many features to plot\nvar max_feature_number = 5\n\n// argsort function found online :\nvar argsort = a => a.map((v, i) => [v, i]).sort().map(i => i[1])\n\n// Standard Normal variate using Box-Muller transform (also found online obviously)\nfunction randn_bm() {\n    var u = 0, v = 0;\n    while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while (v === 0) v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n}\n\n// Shuffle function based on the Fisher-Yates (aka Knuth) Shuffle (once again found online)\nfunction shuffle(array) {\n    let currentIndex = array.length, randomIndex;\n\n    // While there remain elements to shuffle.\n    while (currentIndex != 0) {\n\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n\n    return array;\n}\n\n// Function to get the shap colors\nfunction get_shap_colors(z) {\n    var colors = [];\n    var sorted_z = [...z].sort((a, b) => a - b)\n    first_decile = Math.floor(sorted_z.length * 0.05) - 1;\n    last_decile = Math.floor(sorted_z.length * 0.95) - 1;;\n\n    var z_max = sorted_z[last_decile];\n    var z_min = sorted_z[first_decile];\n\n    var available_colors = [\"#007bff\", \"#0069f8\", \"#5153e9\", \"#7e35d6\", \"#9d00be\", \"#bc00ab\", \"#db009a\", \"#f30086\", \"#ff0071\", \"#ff0059\"];\n\n    for (var i = 0; i < z.length; i++) {\n        if (z_min > z[i]) {\n            colors.push(available_colors[0]);\n        };\n        for (var j = 0; j < available_colors.length; j++) {\n            if (j * (z_max - z_min) / available_colors.length + z_min <= z[i] && (j + 1) * (z_max - z_min) / available_colors.length + z_min > z[i]) {\n                colors.push(available_colors[j]);\n                break;\n            };\n        };\n        if (z_max <= z[i]) {\n            colors.push(available_colors[available_colors.length - 1]);\n        };\n    };\n\n    return { colors, z_min, z_max };\n};\n\n\nfunction get_trace_for_one_feature(not_shuffled_shaps, not_shuffled_values, pos) {\n    // Shuffle the shaps and values\n    var inds = [];\n    for (var i = 0; i < not_shuffled_shaps.length; i++) {\n        inds.push(i);\n    }\n    inds = shuffle(inds);\n    (shaps = []).length = inds.length; shaps.fill(0);\n    (values = []).length = inds.length; values.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        shaps[i] = not_shuffled_shaps[inds[i]];\n        values[i] = not_shuffled_values[inds[i]];\n    }\n\n\n    var n_bins = 100;\n\n    var quant = [];\n    var quant_plus_random = [];\n    var max_shap = Math.max(...shaps);\n    var min_shap = Math.min(...shaps);\n\n    for (var i = 0; i < shaps.length; i++) {\n        quant.push(Math.round(n_bins * (shaps[i] - min_shap) / (max_shap - min_shap)));\n        quant_plus_random.push(quant[i] + randn_bm() * 10 ** (-6));\n    }\n\n    var inds = argsort(quant_plus_random);\n    var layer = 0;\n    var last_bin = -1;\n    var ind = -1;\n    (ys = []).length = shaps.length; ys.fill(0);\n\n    for (var i = 0; i < inds.length; i++) {\n        ind = inds[i];\n        if (!(quant[ind] == last_bin)) {\n            layer = 0;\n        };\n        ys[ind] = Math.ceil(layer / 2) * ((layer % 2) * 2 - 1);\n        layer += 1;\n        last_bin = quant[ind];\n    };\n\n    let { colors, z_min, z_max } = get_shap_colors(values);\n\n    // reverse the x axis and resize the y axis\n    var negative_shaps = [];\n    var resized_ys = [];\n    var row_height = 0.4;\n    for (i = 0; i < shaps.length; i++) {\n        negative_shaps.push(-1 * shaps[i]);\n        resized_ys.push(ys[i] * (0.9 * row_height / (Math.max(...ys) + 1)) + pos);\n    };\n\n    var trace = {\n        x: negative_shaps,\n        y: resized_ys,\n        type: \"scatter\",\n        mode: \"markers\",\n        marker: {\n            color: colors\n        }\n    };\n\n    return trace\n\n};\n\nfunction calculate_variance(shaps) {\n    var result = 0\n    for (i = 0; i < shaps.length; i++) {\n        result += Math.abs(shaps[i])\n    }\n    return result\n}\n\nconsole.log(data);\nvar all_fields = data.series[0].fields;\nvar feature_name = \"\";\nvar list_feature_names = [];\nvar data_dict = {};\nfor (var j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        feature_name = all_fields[j].name.substring(12);\n        data_dict[feature_name] = {};\n        list_feature_names.push(feature_name);\n    };\n};\n\nfor (var j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        feature_name = all_fields[j].name.substring(12)\n        data_dict[feature_name][\"shaps\"] = all_fields[j].values.buffer\n        data_dict[feature_name][\"variance\"] = calculate_variance(all_fields[j].values.buffer)\n    } else if (data_dict.hasOwnProperty(all_fields[j].name)) {\n        feature_name = all_fields[j].name\n        data_dict[feature_name][\"values\"] = all_fields[j].values.buffer\n    }\n}\n\n\n// Sorting the features by decreasing order of variance\nvar sorted_feature_names = list_feature_names.sort(function (first, second) {\n    return data_dict[second].variance - data_dict[first].variance;\n});\n\nvar traces = []\nvar annotations = []\nfor (i = 0; i < Math.min(max_feature_number, sorted_feature_names.length); i++) {\n    traces.push(get_trace_for_one_feature(data_dict[sorted_feature_names[i]][\"shaps\"], data_dict[sorted_feature_names[i]][\"values\"], i + 1))\n    annotations.push(\n        {\n            x: 0,\n            xanchor: 'right',\n            xref: \"paper\",\n            yref: \"paper\",\n            y: 1 - (i + 1) / (Math.min(max_feature_number, sorted_feature_names.length) + 1),\n            yanchor: 'center',\n            text: sorted_feature_names[i],\n            showarrow: false\n        }\n    )\n}\n\n\nvar layout = {\n    font: {\n        color: \"darkgrey\"\n    },\n    paper_bgcolor: \"rgba(0,0,0,0)\",\n    plot_bgcolor: \"rgba(0,0,0,0)\",\n    margin: {\n        \"l\": 120\n    },\n    xaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: true,\n        type: \"linear\"\n    },\n    yaxis: {\n        autorange: true,\n        showgrid: false,\n        showline: false,\n        visible: false,\n        type: \"linear\"\n    },\n    showlegend: false,\n    annotations: annotations\n}\n\nreturn { data: traces, layout: layout };"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  *\nFROM shap_data",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "value_double"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "test_data",
                    "timeColumn": "time_date_time",
                    "timeColumnType": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Shap summary plot",
            "type": "ae3e-plotly-panel"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "aura-influxDB",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 10,
                "w": 12,
                "x": 0,
                "y": 24
            },
            "hiddenSeries": false,
            "id": 7,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "7.3.4",
            "pointradius": 2,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "groupBy": [
                        {
                            "params": [
                                "$__interval"
                            ],
                            "type": "time"
                        },
                        {
                            "params": [
                                "null"
                            ],
                            "type": "fill"
                        }
                    ],
                    "orderByTime": "ASC",
                    "policy": "default",
                    "query": "SELECT mean(\"Tension (uV)\") FROM \"autogen\".\"ecg\" WHERE $timeFilter GROUP BY time($__interval), \"patient\" fill(null)",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "refId": "A",
                    "resultFormat": "time_series",
                    "select": [
                        [
                            {
                                "params": [
                                    "value"
                                ],
                                "type": "field"
                            },
                            {
                                "params": [],
                                "type": "mean"
                            }
                        ]
                    ],
                    "tags": []
                }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "ECG",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "buckets": null,
                "mode": "time",
                "name": null,
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "short",
                    "label": null,
                    "logBase": 1,
                    "max": null,
                    "min": null,
                    "show": true
                },
                {
                    "format": "short",
                    "label": null,
                    "logBase": 1,
                    "max": null,
                    "min": null,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false,
                "alignLevel": null
            }
        },
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 10,
                "w": 12,
                "x": 12,
                "y": 24
            },
            "id": 4,
            "options": {
                "config": null,
                "data": [
                    {
                        "line": {
                            "color": "red",
                            "width": 2
                        },
                        "mode": "markers",
                        "type": "scatter"
                    }
                ],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)",
                    "xaxis": {
                        "autorange": true,
                        "range": [
                            -22187.279151943454,
                            2956187.2791519435
                        ],
                        "type": "linear"
                    }
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "console.log(data)\nvar x = data.series[0].fields[0].values.buffer;\nvar y = data.series[0].fields[1].values.buffer;\nvar z = data.series[0].fields[2].values.buffer;\nvar colors = [];\n\nvar sorted_z = [...z].sort((a, b) => a - b)\nfirst_decile = Math.floor(sorted_z.length*0.05) - 1;\nlast_decile = Math.floor(sorted_z.length*0.95) - 1;;\n\n\nvar z_max = sorted_z[last_decile];\nvar z_min = sorted_z[first_decile];\n//var z_min = 0;\n//var z_max = 31;\nvar z_range = z_max - z_min;\n\nvar available_colors = [\"#007bff\", \"#0069f8\", \"#5153e9\", \"#7e35d6\", \"#9d00be\", \"#bc00ab\", \"#db009a\", \"#f30086\", \"#ff0071\", \"#ff0059\"];\n\nfor (var i = 0; i < z.length; i++) {\n  if (z_min > z[i]) {\n    colors.push(available_colors[0]);\n  };\n  for (var j = 0; j < available_colors.length; j++) {\n    if (j * (z_max - z_min)/available_colors.length + z_min <= z[i] && (j+1) * (z_max - z_min)/available_colors.length + z_min > z[i]) {\n      colors.push(available_colors[j]);\n      break;\n    };\n  };\n  if (z_max <= z[i]) {\n    colors.push(available_colors[available_colors.length - 1]);\n  };\n};\n\nvar trace = {\n  x: x,\n  y: y,\n  marker: {\n    color: colors,\n    colorscale : [[0, \"#007bff\"], [0.1, \"#0069f8\"], [0.2, \"#5153e9\"], [0.3, \"#7e35d6\"], [0.4,\"#9d00be\"], [0.5, \"#bc00ab\"], [0.6, \"#db009a\"], [0.7, \"#f30086\"], [0.8, \"#ff0071\"], [1,\"#ff0059\"]],\n    showscale : true,\n    cmin : z_min,\n    cmax : z_max,\n    }\n};\n\nconsole.log(z_max, z_min)\nconsole.log(trace)\nreturn {data:[trace]};"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  interval_start_time,\n  shap_values_interval_start_time,\n  cvi\nFROM shap_data",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "number"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "my_test_table_2",
                    "timeColumn": "number",
                    "timeColumnType": "float4",
                    "where": [
                        {
                            "name": "$__unixEpochFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Shap plot",
            "type": "ae3e-plotly-panel"
        },
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 16,
                "w": 24,
                "x": 0,
                "y": 34
            },
            "id": 9,
            "options": {
                "config": {
                    "displayModeBar": false
                },
                "data": [],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "l": 200,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)"
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "console.log(data)\nvar all_fields = data.series[0].fields\n\nvar only_shap_value_fields = []\nvar timestamp = []\n\nfor (var j = 0; j < all_fields.length; j++) {\n    if (all_fields[j].name == \"timestamp\") {\n        timestamp = all_fields[j].values.buffer;\n    }\n    if (all_fields[j].name.substring(0, 11) == 'shap_values') {\n        only_shap_value_fields.push(all_fields[j])\n    }\n}\n\nvar data_y = {};\nvar data_x = {}\nfor (var i = 0; i < timestamp.length; i++) {\n    if (!(timestamp[i] in data_y)) {\n        data_y[timestamp[i]] = []\n        data_x[timestamp[i]] = []\n    }\n    for (var j = 0; j < only_shap_value_fields.length; j++) {\n        data_x[timestamp[i]].push(only_shap_value_fields[j].values.buffer[i])\n        data_y[timestamp[i]].push(only_shap_value_fields[j].name)\n    };\n};\n\nvar frames = [];\nfor (var i = 0; i < timestamp.length; i++) {\n    frames.push({\n        name: timestamp[i],\n        data: [{\n            x: data_x[timestamp[i]],\n            y: data_y[timestamp[i]],\n        }],\n    })\n};\n\nvar sliderSteps = [];\nfor (var i = 0; i < timestamp.length; i++) {\n    sliderSteps.push({\n        method: 'animate',\n        label: timestamp[i],\n        args: [[timestamp[i]], {\n            mode: 'immediate',\n            transition: { duration: 0 },\n            frame: { duration: 0, redraw: true },\n        }]\n    });\n}\n\nvar layout = {\n    sliders: [{\n        steps: sliderSteps\n    }]\n};\n\nconsole.log(frames)\n\nvar relative = []\nfor (var i = 0; i < data_x[timestamp[0]].length; i++) {\n    relative.push(\"relative\")\n}\n\n\nvar trace = {\n    x: data_x[timestamp[0]],\n    y: data_y[timestamp[0]],\n    // measure: relative,\n    type: \"waterfall\",\n    // type:\"bar\",\n    orientation: \"h\"\n}\n\nreturn {\n    data: [trace],\n    layout: layout,\n    frames: frames\n};\n"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  *\nFROM shap_data",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "value_double"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "test_data",
                    "timeColumn": "time_date_time",
                    "timeColumnType": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Shap waterfall",
            "type": "ae3e-plotly-panel"
        },
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 10,
                "w": 24,
                "x": 0,
                "y": 50
            },
            "id": 2,
            "options": {
                "config": {
                    "displayModeBar": false
                },
                "data": [
                    {
                        "hoverinfo": "",
                        "orientation": "h",
                        "type": "bar"
                    }
                ],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "l": 170,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)",
                    "showlegend": false,
                    "xaxis": {
                        "range": [
                            -1,
                            1
                        ]
                    }
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "console.log(data)\nvar x = data.series[0].fields[0].values.buffer;\nvar y = data.series[0].fields[1].values.buffer;\nvar timestamp = data.series[0].fields[2].values.buffer;\nvar colors = [];\n\n\nvar data_y = {};\nvar data_x = {}\nvar data_color = {};\nfor (var i = 0; i < x.length; i++) {\n    if (!(timestamp[i] in data_y)) {\n        data_y[timestamp[i]] = []\n        data_x[timestamp[i]] = []\n        data_color[timestamp[i]] = []\n    }\n    data_y[timestamp[i]].push(y[i])\n    data_x[timestamp[i]].push(x[i])\n\n    if (x[i] > 0) {\n        data_color[timestamp[i]].push(\"#23c43e\");\n    } else {\n        data_color[timestamp[i]].push(\"#eb4034\");\n    };\n};\n\nvar frames = [];\nvar unique_timestamps = Object.keys(data_y);\nfor (var i = 0; i < unique_timestamps.length; i++) {\n    frames.push({\n        name: unique_timestamps[i],\n        data: [{\n            x: data_x[unique_timestamps[i]],\n            y: data_y[unique_timestamps[i]],\n            marker: { color: data_color[unique_timestamps[i]] }\n        }],\n    })\n};\n\n\nvar sliderSteps = [];\nfor (var i = 0; i < unique_timestamps.length; i++) {\n    sliderSteps.push({\n        method: 'animate',\n        label: unique_timestamps[i],\n        args: [[unique_timestamps[i]], {\n            mode: 'immediate',\n            transition: { duration: 300 },\n            frame: { duration: 300, redraw: false },\n        }]\n    });\n}\n\nvar layout = {\n    sliders: [{\n        steps: sliderSteps\n    }]\n};\n\n\n\nvar trace = {\n    x: data_x[unique_timestamps[0]],\n    y: data_y[unique_timestamps[0]],\n    type: \"bar\",\n    orientation: \"h\",\n    marker: {\n        color: data_color[unique_timestamps[0]]\n    }\n};\n\nreturn {\n    data: [trace],\n    layout: layout,\n    frames: frames\n};\n"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  lime_coefficient,\n  feature_name,\n  timestamp\nFROM lime_barchart_less_random\nWHERE\n  patient_id = 1234 AND\n  session_id = 5678",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "lime_coefficient"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "lime_barchart",
                    "timeColumn": "lime_coefficient",
                    "timeColumnType": "float4",
                    "where": [
                        {
                            "datatype": "int4",
                            "name": "",
                            "params": [
                                "patient_id",
                                "=",
                                "1234"
                            ],
                            "type": "expression"
                        },
                        {
                            "datatype": "int4",
                            "name": "",
                            "params": [
                                "session_id",
                                "=",
                                "5678"
                            ],
                            "type": "expression"
                        }
                    ]
                },
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  feature_name\nFROM lime_barchart\nWHERE\n  patient_id = 1234 AND\n  session_id = 5678",
                    "refId": "B",
                    "select": [
                        [
                            {
                                "params": [
                                    "value_double"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "test_data",
                    "timeColumn": "time_date_time",
                    "timeColumnType": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Animated panel",
            "type": "ae3e-plotly-panel"
        },
        {
            "datasource": "Postgres",
            "fieldConfig": {
                "defaults": {
                    "custom": {}
                },
                "overrides": []
            },
            "gridPos": {
                "h": 9,
                "w": 24,
                "x": 0,
                "y": 60
            },
            "id": 5,
            "options": {
                "config": {
                    "displayModeBar": false
                },
                "data": [
                    {
                        "hoverinfo": "",
                        "orientation": "h",
                        "type": "bar"
                    }
                ],
                "layout": {
                    "font": {
                        "color": "darkgrey"
                    },
                    "margin": {
                        "b": 20,
                        "l": 170,
                        "t": 30
                    },
                    "paper_bgcolor": "rgba(0,0,0,0)",
                    "plot_bgcolor": "rgba(0,0,0,0)",
                    "showlegend": false
                },
                "onclick": "console.log(data)\nwindow.updateVariables({query:{'var-project':'test'}, partial: true})",
                "script": "console.log(data)\nvar x = data.series[0].fields[0].values.buffer;\nvar y = data.series[0].fields[1].values.buffer;\nvar timestamp = data.series[0].fields[2].values.buffer;\nvar colors = [];\n\n\nvar data_y = {};\nvar data_x = {}\nvar data_color = {};\nfor (var i = 0; i < x.length; i++) {\n    if (!(timestamp[i] in data_y)) {\n        data_y[timestamp[i]] = []\n        data_x[timestamp[i]] = []\n        data_color[timestamp[i]] = []\n    }\n    data_y[timestamp[i]].push(y[i])\n    data_x[timestamp[i]].push(x[i])\n\n    if (x[i] > 0) {\n        data_color[timestamp[i]].push(\"#23c43e\");\n    } else {\n        data_color[timestamp[i]].push(\"#eb4034\");\n    };\n};\n\nvar frames = [];\nvar unique_timestamps = Object.keys(data_y);\nfor (var i = 0; i < unique_timestamps.length; i++) {\n    frames.push({\n        name: unique_timestamps[i],\n        data: [{\n            x: data_x[unique_timestamps[i]],\n            y: data_y[unique_timestamps[i]],\n            marker: { color: data_color[unique_timestamps[i]] }\n        }],\n    })\n};\n\n\nvar sliderSteps = [];\nfor (var i = 0; i < unique_timestamps.length; i++) {\n    sliderSteps.push({\n        method: 'animate',\n        label: unique_timestamps[i],\n        args: [[unique_timestamps[i]], {\n            mode: 'immediate',\n            transition: { duration: 300 },\n            frame: { duration: 300, redraw: false },\n        }]\n    });\n}\n\nvar layout = {\n    sliders: [{\n        steps: sliderSteps\n    }]\n};\n\n\n\nvar trace = {\n    x: data_x[unique_timestamps[0]],\n    y: data_y[unique_timestamps[0]],\n    type: \"bar\",\n    orientation: \"h\",\n    marker: {\n        color: data_color[unique_timestamps[0]]\n    }\n};\n\nreturn {\n    data: [trace],\n    layout: layout,\n    frames: frames\n};\n"
            },
            "pluginVersion": "7.3.4",
            "targets": [
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "queryType": "randomWalk",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  lime_coefficient,\n  feature_name,\n  timestamp\nFROM lime_barchart\nWHERE\n  patient_id = 1234 AND\n  session_id = 5678",
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": [
                                    "lime_coefficient"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "lime_barchart",
                    "timeColumn": "lime_coefficient",
                    "timeColumnType": "float4",
                    "where": [
                        {
                            "datatype": "int4",
                            "name": "",
                            "params": [
                                "patient_id",
                                "=",
                                "1234"
                            ],
                            "type": "expression"
                        },
                        {
                            "datatype": "int4",
                            "name": "",
                            "params": [
                                "session_id",
                                "=",
                                "5678"
                            ],
                            "type": "expression"
                        }
                    ]
                },
                {
                    "format": "table",
                    "group": [],
                    "metricColumn": "none",
                    "rawQuery": true,
                    "rawSql": "SELECT\n  feature_name\nFROM lime_barchart\nWHERE\n  patient_id = 1234 AND\n  session_id = 5678",
                    "refId": "B",
                    "select": [
                        [
                            {
                                "params": [
                                    "value_double"
                                ],
                                "type": "column"
                            }
                        ]
                    ],
                    "table": "test_data",
                    "timeColumn": "time_date_time",
                    "timeColumnType": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "timeFrom": null,
            "timeShift": null,
            "title": "Animated panel random",
            "type": "ae3e-plotly-panel"
        }
    ],
    "refresh": false,
    "schemaVersion": 26,
    "style": "dark",
    "tags": [],
    "templating": {
        "list": []
    },
    "time": {
        "from": "2006-10-09T06:56:49.000Z",
        "to": "2006-10-09T07:34:22.000Z"
    },
    "timepicker": {},
    "timezone": "",
    "title": "Plotly panel",
    "uid": "I6mfmZwnk",
    "version": 10
}